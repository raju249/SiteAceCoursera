{"version":3,"sources":["meteor://ðŸ’»app/packages/arkham_comments-ui/lib/model.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H","file":"/packages/arkham_comments-ui.js","sourcesContent":["Comments = (function () {\n  var timeTick = new Tracker.Dependency(),\n    collection = new Mongo.Collection('comments'),\n    noOptOptions = {\n      validate: false,\n      filter: false,\n      getAutoValues: false,\n      removeEmptyStrings: false\n    },\n    ReplySchema, CommentSchema;\n\n  moment.locale('en');\n\n  /*\n   * Helper Functions\n   */\n\n  function transformUser(userId) {\n    var user = Meteor.users.findOne(userId),\n      displayName;\n\n    if (user) {\n      if (user.emails && user.emails[0]) {\n        displayName = user.emails[0].address;\n      }\n\n      if (user.username) {\n        displayName = user.username;\n      }\n\n      return { displayName: displayName };\n    }\n  }\n\n  function transformReplies(scope, position) {\n    if (!position) {\n      position = [];\n    }\n\n    return _.map(scope.replies, function (reply, index) {\n      position.push(index);\n\n      reply.position = position;\n      reply.documentId = scope._id;\n\n      reply.user = scope.user.bind(reply);\n      reply.likesCount = scope.likesCount.bind(reply);\n      reply.createdAgo = scope.createdAgo.bind(reply);\n\n      // clone position\n      reply.position = position.slice(0);\n\n      if (reply.replies) {\n        // recursive!\n        reply.enhancedReplies = _.bind(transformReplies, null, _.extend(_.clone(scope), { replies: reply.replies }), position)();\n      }\n\n      position.pop();\n\n      return reply;\n    });\n  }\n\n  function modifyNestedReplies(nestedArray, position, callback) {\n    var currentPos = position.shift();\n\n    if (nestedArray[currentPos]) {\n      if (position.length && nestedArray[currentPos] && nestedArray[currentPos].replies) {\n        modifyNestedReplies(nestedArray[currentPos].replies, position, callback);\n      } else {\n        callback(nestedArray, currentPos);\n      }\n    }\n  }\n\n  function getUserIdsByComment(comment) {\n    var ids = [];\n\n    ids.push(comment.userId);\n\n    if (comment.replies) {\n      _.each(comment.replies, function (reply) {\n        ids = _.union(ids, getUserIdsByComment(reply));\n      });\n    }\n\n    return ids;\n  }\n\n  function getImageFromContent(content) {\n    var urls;\n\n    if (content) {\n      urls = content.match(/(\\S+\\.[^/\\s]+(\\/\\S+|\\/|))(.jpg|.png|.gif)/g) ;\n\n      if (urls && urls[0]) {\n        return urls[0];\n      }\n    }\n\n    return '';\n  }\n\n  /*\n   * Schema Definitions\n   */\n\n  ReplySchema = new SimpleSchema({\n    replyId: {\n      type: String\n    },\n    userId: {\n      type: String\n    },\n    image: {\n      type: String,\n      optional: true,\n      autoValue: function () {\n        return getImageFromContent(this.siblingField('content').value);\n      }\n    },\n    content: {\n      type: String,\n      min: 1,\n      max: 10000\n    },\n    replies: {\n      type: [Object],\n      autoValue: function (doc) {\n        if (this.isInsert) {\n          return [];\n        }\n      },\n      optional: true\n    },\n    likes: {\n      type: [String],\n      autoValue: function() {\n        if (this.isInsert) {\n          return [];\n        }\n      },\n      optional: true\n    },\n    createdAt: {\n      type: Date,\n      autoValue: function() {\n        if (this.isInsert) {\n          return new Date;\n        } else if (this.isUpsert) {\n          return {$setOnInsert: new Date};\n        } else {\n          this.unset();\n        }\n      }\n    },\n    lastUpdatedAt: {\n      type: Date,\n      autoValue: function() {\n        if (this.isUpdate) {\n          return new Date();\n        }\n      },\n      denyInsert: true,\n      optional: true\n    }\n  });\n\n  CommentSchema = new SimpleSchema({\n    userId: {\n      type: String\n    },\n    referenceId: {\n      type: String\n    },\n    image: {\n      type: String,\n      optional: true,\n      autoValue: function () {\n        return getImageFromContent(this.siblingField('content').value);\n      }\n    },\n    content: {\n      type: String,\n      min: 1,\n      max: 10000\n    },\n    replies: {\n      type: [Object],\n      autoValue: function () {\n        if (this.isInsert) {\n          return [];\n        }\n      },\n      optional: true\n    },\n    likes: {\n      type: [String],\n      autoValue: function() {\n        if (this.isInsert) {\n          return [];\n        }\n      },\n      optional: true\n    },\n    createdAt: {\n      type: Date,\n      autoValue: function() {\n        if (this.isInsert) {\n          return new Date;\n        } else if (this.isUpsert) {\n          return {$setOnInsert: new Date};\n        } else {\n          this.unset();\n        }\n      }\n    },\n    lastUpdatedAt: {\n      type: Date,\n      autoValue: function() {\n        if (this.isUpdate) {\n          return new Date();\n        }\n      },\n      denyInsert: true,\n      optional: true\n    }\n  });\n\n  /*\n   * Model Configuration\n   */\n\n  // Reactive moment changes\n  Meteor.setInterval(function () {\n    timeTick.changed();\n  }, 1000);\n\n  function fromNowReactive(mmt) {\n    timeTick.depend();\n    return mmt.fromNow();\n  }\n\n  collection.attachSchema(CommentSchema);\n\n  // Is handled with Meteor.methods\n  collection.allow({\n    insert: function () { return false; },\n    update: function () { return false; },\n    remove: function () { return false; }\n  });\n\n  collection.helpers({\n    likesCount: function () {\n      if (this.likes && this.likes.length) {\n        return this.likes.length;\n      }\n\n      return 0;\n    },\n    user: function () {\n      return transformUser(this.userId);\n    },\n    createdAgo: function () {\n      return fromNowReactive(moment(this.createdAt));\n    },\n    enhancedReplies: function (position) {\n      return transformReplies(this);\n    }\n  });\n\n  /*\n   * Meteor Methods\n   */\n\n  Meteor.methods({\n    'comments/add': function (referenceId, content) {\n      check(referenceId, String);\n      check(content, String);\n\n      content = content.trim();\n\n      if (!this.userId || !content) {\n        return;\n      }\n\n      collection.insert(\n          { referenceId: referenceId, content: content, userId: this.userId, createdAt: (new Date()), likes: [], replies: [] }\n      );\n    },\n    'comments/edit': function (documentId, newContent) {\n      check(documentId, String);\n      check(newContent, String);\n\n      newContent = newContent.trim();\n\n      if (!this.userId || !newContent) {\n        return;\n      }\n\n      collection.update(\n        { _id: documentId, userId: this.userId },\n        { $set: { content: newContent, likes: [], image: getImageFromContent(newContent) } }\n      );\n    },\n    'comments/remove': function (documentId) {\n      check(documentId, String);\n      collection.remove({ _id: documentId, userId: this.userId });\n    },\n    'comments/like': function (documentId) {\n      check (documentId, String);\n      check(this.userId, String);\n\n      if (!this.userId) {\n        return;\n      }\n\n      if (collection.findOne({ _id: documentId, likes: { $in: [this.userId] } })) {\n        collection.update({ _id: documentId }, { $pull: { likes: this.userId } }, noOptOptions)\n      } else {\n        collection.update({ _id: documentId }, { $push: { likes: this.userId } }, noOptOptions)\n      }\n    },\n    'comments/reply/add': function (documentId, docScope, content) {\n      check(documentId, String);\n      check(docScope, Object);\n      check(content, String);\n\n      var doc = collection.findOne({ _id: documentId }),\n          reply;\n\n      content = content.trim();\n\n      if (!doc || !this.userId || !content) {\n        return false;\n      }\n\n      reply = {\n        replyId: Random.id(),\n        content: content,\n        userId: this.userId,\n        createdAt: (new Date()),\n        replies: [], likes: [],\n        lastUpdatedAt: (new Date())\n      };\n\n      check(reply, ReplySchema);\n\n      if (docScope._id) {\n        // highest level reply\n        doc.replies.unshift(reply);\n      } else if (docScope.position) {\n        // nested reply\n        modifyNestedReplies(doc.replies, docScope.position, function (replies, index) {\n          replies[index].replies.unshift(reply);\n        });\n      }\n\n      collection.update({ _id: documentId }, { $set: { replies: doc.replies } }, noOptOptions);\n    },\n    'comments/reply/edit': function (documentId, docScope, newContent) {\n      check(documentId, String);\n      check(docScope, Object);\n      check(newContent, String);\n\n      var doc = collection.findOne(documentId),\n          userId = this.userId;\n\n      newContent = newContent.trim();\n\n      if (!userId || !newContent) {\n        return;\n      }\n\n      modifyNestedReplies(doc.replies, docScope.position, function (replies, index) {\n        if (replies[index].userId === userId) {\n          replies[index].content = newContent;\n          replies[index].likes = [];\n          replies[index].image = getImageFromContent(newContent);\n        }\n      });\n\n      collection.update({ _id: documentId }, { $set: { replies: doc.replies } }, noOptOptions);\n    },\n    'comments/reply/like': function (documentId, docScope) {\n      check(documentId, String);\n      check(docScope, Object);\n\n      var doc = collection.findOne({ _id: documentId }),\n          userId = this.userId;\n\n      if (!userId) {\n        return;\n      }\n\n      modifyNestedReplies(doc.replies, docScope.position, function (replies, index) {\n        if (replies[index].likes.indexOf(userId) > -1) {\n          replies[index].likes.splice(replies[index].likes.indexOf(userId), 1);\n        } else {\n          replies[index].likes.push(userId);\n        }\n      });\n\n      collection.update({ _id: documentId }, { $set: { replies: doc.replies }  }, noOptOptions);\n    },\n    'comments/reply/remove': function (documentId, docScope) {\n      check(documentId, String);\n      check(docScope, Object);\n\n      var doc = collection.findOne({ _id: documentId }),\n          userId = this.userId;\n\n      if (!userId) {\n        return;\n      }\n\n      modifyNestedReplies(doc.replies, docScope.position, function (replies, index) {\n        if (replies[index].userId === userId) {\n          replies.splice(index, 1);\n        }\n      });\n\n      collection.update({ _id: documentId }, { $set: { replies: doc.replies }  }, noOptOptions);\n    },\n    'comments/count': function (referenceId) {\n      check(referenceId, String);\n      return collection.find({ referenceId: referenceId }).count();\n    }\n  });\n\n\n  if (Meteor.isServer) {\n    Meteor.publishComposite('comments/reference', function (id, limit) {\n      check(id, String);\n      check(limit, Number);\n\n      return {\n        find: function () {\n          return collection.find({ referenceId: id }, { limit: limit, sort: { createdAt: -1 } });\n        },\n        children: [{\n          find: function (comment) {\n            var userIds = getUserIdsByComment(comment);\n\n            return Meteor.users.find({ _id: { $in: userIds } }, { fields: { profile: 1, emails: 1, username: 1 } });\n          }\n        }]\n      };\n    })\n  }\n\n  /*\n   * Public API\n   */\n\n  return {\n    get: function (id) {\n      return collection.find({ referenceId: id }, { sort: { createdAt: -1 } });\n    },\n    getOne: function (id) {\n      return collection.findOne({ _id: id });\n    },\n    getAll: function () {\n      return collection.find({}, { sort: { createdAt: -1 } });\n    },\n    add: function (referenceId, content) {\n      Meteor.call('comments/add', referenceId, content);\n    },\n    edit: function (documentId, newContent) {\n      Meteor.call('comments/edit', documentId, newContent);\n    },\n    remove: function (documentId) {\n      Meteor.call('comments/remove', documentId);\n    },\n    like: function (documentId) {\n      Meteor.call('comments/like', documentId);\n    },\n    reply: function (documentId, docScope, content) {\n      Meteor.call('comments/reply/add', documentId, docScope, content);\n    },\n    editReply: function (documentId, docScope, content) {\n      Meteor.call('comments/reply/edit', documentId, docScope, content);\n    },\n    removeReply: function (documentId, docScope) {\n      Meteor.call('comments/reply/remove', documentId, docScope);\n    },\n    likeReply: function (documentId, docScope) {\n      Meteor.call('comments/reply/like', documentId, docScope);\n    },\n    session: {\n      set: function (key, val) {\n        return Session.set('commentsUi_' + key, val);\n      },\n      get: function (key) {\n        return Session.get('commentsUi_' + key);\n      },\n      equals: function (key, val) {\n        return Session.equals('commentsUi_' + key, val);\n      }\n    },\n    changeSchema: function (cb) {\n      var currentSchema = collection.simpleSchema().schema(),\n        callbackResult = cb(currentSchema),\n        newSchema;\n\n      newSchema = callbackResult ? callbackResult : currentSchema;\n      !!newSchema && collection.attachSchema(newSchema, { replace: true });\n    },\n    _collection: collection\n  };\n})();\n"]}